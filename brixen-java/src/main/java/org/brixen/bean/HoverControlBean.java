package org.brixen.bean;

import org.openqa.selenium.WebElement;
import org.openqa.selenium.interactions.Actions;

/**
 * Defines the contract for a data transfer object used to construct a <b>Selenium</b> page object that models a
 * web control that has meaningful side effects whenever it is moused over.
 */
public interface HoverControlBean extends ControlBean {

    /**
     * Sets the element to send the focus to when unhovering the web control.
     * <p>
     * The unhover element should be carefully chosen to ensure that any content that is rendered visible by mousing
     * over the web control is rendered invisible and that the mouseover action on the unhover element does not trigger
     * visibility for any other content panes that you wish to remain hidden or trigger any other undesired side
     * effects.
     *
     * @param unhoverElement      the {@code WebElement} to mouse over in order to unhover the web control by
     *                            ensuring that mouse is focused in a safe location away from it
     */
    void setUnhoverElement(WebElement unhoverElement);

    /**
     * Gets the element to send the focus to when unhovering the web control.
     *
     * @return  the element to send the focus to when unhovering the web control
     */
    WebElement getUnhoverElement();

    /**
     * Enables or disables the Javascript hover workaround for the web control.
     * <p>
     * Enabling the Javascript hover workaround will invoke a mouse over action on the web control with Javascript
     * rather than using {@link Actions#moveToElement} method. This is useful in circumstances where the mouse over
     * function fails silently, that is the {@link Actions#moveToElement} runs without throwing any {@code Exceptions},
     * but the element is not really moused over.
     *
     * @param hoverWithJavascript    if {@code true}, enables the Javascript hover workaround; {@code false} to disable
     *                               it
     */
    void setHoverWithJavascript(boolean hoverWithJavascript);

    /**
     * Determines whether the Javascript hover workaround for the web control is enabled.
     * <p>
     * If enabled, Javascript will be used to execute a mouse over on the web control. If not, the
     * {@link Actions#moveToElement} method will be used.
     *
     * @return      {@code true} if the Javascript hover workaround is enabled; {@code false} otherwise
     */
    boolean getHoverWithJavascript();

    /**
     * Enables or disables the Javascript hover workaround for the unhover element which is used to focus the mouse in
     * a safe location away from the web control.
     * <p>
     * Enabling the Javascript hover workaround will invoke a mouse over action on the unhover element with Javascript
     * rather than using {@link Actions#moveToElement} method. This is useful in circumstances where the mouse over
     * function fails silently, that is the {@link Actions#moveToElement} runs without throwing any {@code Exceptions},
     * but the element is not really moused over.
     *
     * @param unhoverWithJavascript    if {@code true}, enables the Javascript hover workaround; {@code false} to
     *                                 disable it
     */
    void setUnhoverWithJavascript(boolean unhoverWithJavascript);

    /**
     * Determines whether the Javascript hover workaround is enabled for the unhover element which is used to focus
     * the mouse in a safe location away from the web control.
     * <p>
     * If enabled, Javascript will be used to execute a mouse over on the unhover element. If not, the
     * {@link Actions#moveToElement} method will be used.
     *
     * @return      {@code true} if the Javascript hover workaround is enabled; {@code false} otherwise
     */
    boolean getUnhoverWithJavascript();

    /**
     * Enables or disables the {@link WebElement#click} action workaround for forcing the mouse to focus on the web
     * control.
     * <p>
     * Note: It is best to use this in situations where both the {@link Actions#moveToElement} method and the
     * Javascript hover workaround fail silently, that is {@link Actions#moveToElement} and the Javascript hover
     * workaround run without throwing any {@code Exceptions}, but the element is not really moused over. This will
     * allow automation of test cases which are dependent on the side effects generated by the hover action, but are
     * not related to testing that the hover action alone triggers the desired side effects. In such cases, it would be
     * prudent to manually test the hover action alone in the environment(s) where neither the
     * {@link Actions#moveToElement} nor the Javascript hover workaround trigger the mouseover event and the expected
     * side effect(s).
     *
     * @param clickInsteadOfHover   if {@code true}, enables the {@link WebElement#click} action workaround;
     *                              {@code false} to disable it
     */
    void setClickInsteadOfHover(boolean clickInsteadOfHover);

    /**
     * Determines whether the {@link WebElement#click} action workaround for forcing the mouse to focus on the web
     * control is enabled.
     *
     * @return  {@code true} if the click action workaround is enabled; {@code false} otherwise
     * @see #setClickInsteadOfHover(boolean) for caveats about this workaround.
     */
    boolean getClickInsteadOfHover();

    /**
     * Enables or disables the Javascript click action workaround for forcing the mouse to focus on the web control.
     * <p>
     * Note: It is best to use this in situations where the {@link Actions#moveToElement} method, the Javascript hover
     * workaround and the {@link WebElement#click} method all fail silently, that is they all run without throwing any
     * {@code Exceptions}, but the element is not really moused over or clicked. This will allow automation of test
     * cases which are dependent on the side effects generated by the hover action, but are not related to testing that
     * the hover action alone triggers the desired side effects. In such cases, it would be prudent to manually test
     * the hover action alone in the environment(s) where neither the {@link Actions#moveToElement} nor the Javascript
     * hover workaround trigger the mouseover event and the expected side effect(s).
     *
     * @param clickWithJavascriptInsteadOfHover     if {@code true}, enables the Javascript click action workaround;
     *                                              {@code false} to disable it
     */
    void setClickWithJavascriptInsteadOfHover(boolean clickWithJavascriptInsteadOfHover);

    /**
     * Determines whether the Javascript click action workaround for forcing the mouse to focus on the web control is
     * enabled.
     *
     * @return  {@code true} if the Javascript click action workaround is enabled; {@code false} otherwise
     * @see #setClickWithJavascriptInsteadOfHover(boolean) for caveats about this workaround.
     */
    boolean getClickWithJavascriptInsteadOfHover();

    /**
     * Enables or disables the {@link WebElement#click} action workaround for the unhover element which is used to
     * focus the mouse in a safe location away from the web control.
     * <p>
     * Care should be taken to ensure that clicking on the unhover element does not trigger undesired side effects and
     * serves only to force the mouse away from the web control. This action is riskier than hovering the mouse over
     * the unhover element, so it should be used in situations where the {@link Actions#moveToElement} method and the
     * Javascript hover workaround fail silently, that is {@link Actions#moveToElement} and the Javascript hover
     * workaround run without throwing any {@code Exceptions}, but the element is not really moused over.
     *
     * @param unhoverWithClickInstead  if {@code true}, enables the {@link WebElement#click} action workaround for the
     *                                 unhover element; {@code false} to disable it
     */
    void setUnhoverWithClickInstead(boolean unhoverWithClickInstead);

    /**
     * Determines whether the {@link WebElement#click} action workaround for the unhover element which is used to
     * focus the mouse in a safe location away from the web control is enabled.
     *
     * @return  {@code true} if the click action workaround is enabled; {@code false} otherwise
     * @see #setUnhoverWithClickInstead(boolean) for caveats about this workaround.
     */
    boolean getUnhoverWithClickInstead();

    /**
     * Enables or disables the Javascript click action workaround for the unhover element which is used to focus the
     * mouse in a safe location away from the web control.
     * <p>
     * Care should be taken to ensure that clicking on the unhover element does not trigger undesired side effects and
     * serves only to force the mouse away from the web control. This action is riskier than hovering the mouse over
     * the unhover element, so it should be used in situations where the {@link Actions#moveToElement} method, the
     * Javascript hover workaround and the {@link WebElement#click} method fail silently, that is they run without
     * throwing any {@code Exceptions}, but the element is not really moused over or clicked.
     *
     * @param unhoverWithJavascriptClickInstead  if {@code true}, enables the Javascript click action workaround for
     *                                           the unhover element; {@code false} to disable it
     */
    void setUnhoverWithJavascriptClickInstead(boolean unhoverWithJavascriptClickInstead);

    /**
     * Determines whether the Javascript click action workaround for the unhover element which is used to focus the
     * mouse in a safe location away from the web control is enabled.
     *
     * @return  {@code true} if the Javascript click action workaround is enabled; {@code false} otherwise
     * @see #setUnhoverWithJavascriptClickInstead(boolean) for caveats about this workaround
     */
    boolean getUnhoverWithJavascriptClickInstead();
}
